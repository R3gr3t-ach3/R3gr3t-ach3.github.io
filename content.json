{"meta":{"title":"R3gr3t's blog","subtitle":"","description":"","author":"R3gr3t","url":"http://R3gr3t-ach3.github.io","root":"/"},"posts":[{"tags":[{"name":"CTF","slug":"CTF","permalink":"http://r3gr3t-ach3.github.io/tags/CTF/"},{"name":"re","slug":"re","permalink":"http://r3gr3t-ach3.github.io/tags/re/"},{"name":"crypto","slug":"crypto","permalink":"http://r3gr3t-ach3.github.io/tags/crypto/"}],"title":"Midnight Sun CTF 2020 Quals WP","date":"2020/04/05","text":"只做了一道re + crypto，还没有搞出来，把wp记录一下 反编译后的py： import string, sys, hashlib, binasciifrom Crypto.Cipher import AESfrom flag import keyassert len(key) == 42data = open(sys.argv[1], 'rb').read()assert len(data) >= 191FIBOFFSET = 4919MAXFIBSIZE = len(key) + len(data) + FIBOFFSETdef fibseq(n): out = [ 0, 1] for i in range(2, n): out += [out[(i - 1)] + out[(i - 2)]] return outFIB = fibseq(MAXFIBSIZE)i = 0output = ''while i < len(data): data1 = data[(FIB[i] % len(data))] key1 = key[((i + FIB[(FIBOFFSET + i)]) % len(key))] i += 1 data2 = data[(FIB[i] % len(data))] key2 = key[((i + FIB[(FIBOFFSET + i)]) % len(key))] i += 1 tohash = bytes([data1, data2]) toencrypt = hashlib.md5(tohash).hexdigest() thiskey = bytes([key1, key2]) * 16 cipher = AES.new(thiskey, AES.MODE_ECB) enc = cipher.encrypt(toencrypt) output += binascii.hexlify(enc).decode('ascii')print(output) pybonbash 反编译pybonbash.cpython-36.pyc 首先计算斐波那契数列并存为一个列表，长度为4919+len(key)+len(data)，key是长度为42的flag，data的长度是204(通过给定的”hash.txt”计算)。然后，它将data1和data2设置为data中的两个字符，key1和key2为key中的两个字符。最后，在AES-ECB中使用md5(data1+data2)作为明文，(key1+key2)*16作为密钥，将16进制的结果输出到”hash.txt”中。 我们不知道明文和密钥，但知道md5(data1+data2)由”0123456789abcdef”组成，因此尝试key1和key2的所有组合，并检查解密文本是否为md5格式。 exp： import stringfrom Crypto.Cipher import AESkey_len = 42data_len = 204FIBOFFSET = 4919MAXFIBSIZE = key_len + data_len + FIBOFFSETdef fibseq(n): out = [0, 1] for i in range(2, n): out += [out[(i-1)] + out[(i-2)]] return outdef check_hash(str_): cs = '0123456789abcdef' for s in str_: if s not in cs: return False return TrueFIB = fibseq(MAXFIBSIZE)flag = {}hashtxt = open('hash.txt').read().strip()for i in range(0, data_len, 2): key1_index = (i + FIB[FIBOFFSET + i]) % key_len key2_index = (i + 1 + FIB[FIBOFFSET + i + 1]) % key_len h = hashtxt[i*32 : (i+2)*32].decode('hex') for i in string.printable: for j in string.printable: k = (i + j) * 16 cipher = AES.new(k, AES.MODE_ECB) dec = cipher.decrypt(h) if check_hash(dec): flag[key1_index] = k[0] flag[key2_index] = k[1] print('{}, {}, {}'.format(key1_index, key2_index, k)) print('done')flag_str = ''for i in range(42): flag_str += flag[i]print(flag_str) >没想到md5后的数值只有\"0123456789abcdef\"，单纯的爆破时间不够 = =","permalink":"http://r3gr3t-ach3.github.io/2020/04/05/Midnight-Sun-CTF-2020-Quals/","photos":[]}],"categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://r3gr3t-ach3.github.io/tags/CTF/"},{"name":"re","slug":"re","permalink":"http://r3gr3t-ach3.github.io/tags/re/"},{"name":"crypto","slug":"crypto","permalink":"http://r3gr3t-ach3.github.io/tags/crypto/"}]}